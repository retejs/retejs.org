---
description: Исследуйте нашу систему плагинов и посмотрите, как она может улучшить функциональность вашего проекта. Наш пример кода показывает, как сигналы передаются между родительскими и дочерними плагинами.
keywords: плагин, область, родительский, дочерний, addpipe, сигналы
---

# Система плагинов

::references
:ref-github{title="Исходный код" link="https://github.com/retejs/rete/blob/main/src/scope.ts"}
::

Плагины предоставляют возможность добавлять новые функции в основном через одну точку входа. Они взаимодействуют друг с другом с помощью сигналов, которые передаются от родительских плагинов к дочерним. Поскольку плагины могут иметь несколько дочерних плагинов, эти сигналы передаются в порядке их подключения (это может быть важно при включении плагинов, таких как `rete-readonly-plugin`).

:diagram{name="plugin-system/architecture" caption="Архитектура"}

Следующий пример кода демонстрирует создание двух областей: родительской и дочерней. Обе области регистрируют сигналы.

```ts
import { Scope } from 'rete';

const parentScope = new Scope<number>('parent'); // number это производимый тип
const childScope = new Scope<string, [number]>('child'); // [number] это ожидаемый тип родительской цепочки

parentScope.addPipe((context) => { // добавить pipe к родительской области
  console.log('parent', context); // number

  return context;
});

childScope.addPipe((context) => { // добавить pipe к дочерней области
  console.log('child', context); // string | number

  return context;
});

parentScope.use(childScope); // forward all signals to child scope

const returnedNumber = await parentScope.emit(1); // can emit number
const returnedString = await childScope.emit('a'); // can emit string
```

Обратите внимание, что порядок `use` и `addPipe` влияет на порядок вызова родительских и дочерних обработчиков.

Логи:
```log
parent 1
child 1
child a
```

В некоторых случаях сигналы можно изменять или блокировать.

:diagram{name="plugin-system/addPipe" caption="Блокировать или изменить"}

```ts
parentScope.addPipe((context) => {
  return context * 2;
});
childScope.addPipe((context) => {
  if (context === 'b') return // предотвращение распространения 'b'
  return context;
});

const doubledNumber = await parentScope.emit(1); // 2
const expectedString = await childScope.emit('a'); // 'a'
const expectedUndefined = await childScope.emit('b'); // undefined
```

Статическая типизация используется для обеспечения совместимости ожидаемых сигналов используемых плагинов с сигналами, созданными родительским плагином.

```ts
import { Scope } from 'rete';

const parentScope = new Scope<number>('parent');
const childScope = new Scope<string, [number | boolean]>('child');

parentScope.use(childScope); // Type 'boolean' is not assignable to type 'string | number'.ts(2345)
```

Дочерние плагины могут получить доступ к экземпляру родительского плагина как для прямого доступа к его интерфейсам, так и для генерации сигналов от имени родительского плагина.

```ts
import { Scope } from 'rete';

class Root extends Scope<number> {
  isRoot = true
}

class Root2 extends Scope<number> {
  isRoot2 = true
}

const parentScope = new Root('parent');
const childScope = new Scope<string, [number]>('child');

parentScope.use(childScope);

const parent = childScope.parentScope(); // экземпляр Root, но Scope с точки зрения TS
const root = childScope.parentScope<Root>(Root); // экземпляр Root
const wrongInstance = childScope.parentScope<Root2>(Root2); // выбрасывает исключение
```
